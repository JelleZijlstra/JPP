<h2>Background and evaluation</h2>
<p>I chose to work on computational phylogenetics because it is a tool that I have often used in my research (e.g., <a href="http://dx.doi.org/10.1644/09-MAMM-A-208.1">Zijlstra et al., 2010</a>; <a href="www.mapress.com/zootaxa/2012/f/z03534p068f.pdf">Zijlstra, 2012</a>). I used existing programs like PAST, TNT, and POY for my analyses. However, I never gained a detailed understanding of the underlying algorithms or of the way they are implemented. With this project, I hoped to explore these topics and also to find ways to run phylogenetic algorithms in parallel. I did not expect to be able to replicate the performance or feature set of existing programs, which are large projects that have been in development for a long time.</p>

<p>It did not disappoint. I enjoyed learning about the algorithms involved in tree reconstruction and thinking about how to implement them. Perhaps the most challenging part was the tree parser in <tt>tree_parse.py</tt>&mdash;even though I was able to use the rules generated by Yacc from the simple grammar, actually implementing the rest of a shift/reduce parser myself turned out to be difficult. For many reasons, it would have been better to use some sort of parsing library or parsing generator: less opportunity for bugs in the parser implementation, easier to change the grammar, simpler to understand the grammar from the code. On the other hand, this is an educational project, and there is educational value in actually writing something like a parser. It was also difficult but rewarding to implement some algorithms (e.g., tree fusion) for which I could find little detailed information on implementation.</p>

<p>If I had to do this project again, I would invest more time and energy in investigating how existing programs represent trees and implement algorithms on them. I had to come up with the details of representing trees in the program and implementing the heuristic algorithms on my own, and while my implementations work and perform reasonably well, the program might have done better if I had incorporated other ideas.</p>
